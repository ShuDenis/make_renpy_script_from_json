"""Wrapper for dialog generation functionality."""
from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, List

# Helper functions

def _quote(s: str) -> str:
    """Return a JSON-style quoted string preserving non-ASCII characters."""
    return json.dumps(s, ensure_ascii=False)


def _apply_text_tags(text: str, tags: List[str] | None) -> str:
    """Wrap ``text`` with Ren'Py text tags provided in ``tags``."""
    if not tags:
        return text
    open_parts: List[str] = []
    close_parts: List[str] = []
    for tag in tags:
        if "=" in tag:
            name, value = tag.split("=", 1)
            open_parts.append(f"{{{name}={value}}}")
            close_parts.insert(0, f"{{/{name}}}")
        else:
            open_parts.append(f"{{{tag}}}")
            close_parts.insert(0, f"{{/{tag}}}")
    return "".join(open_parts) + text + "".join(close_parts)


def _wrap_text(text: str, tags: List[str] | None = None, localize: bool = True) -> str:
    """Quote ``text`` and wrap it for localisation and tags."""
    text = _apply_text_tags(text, tags)
    quoted = _quote(text)
    return f"_({quoted})" if localize else quoted


# Node emitters

def _emit_say(tree_id: str, node: Dict[str, Any], default_char: str, localize: bool) -> List[str]:
    lines: List[str] = []
    voice = node.get("voice")
    if voice:
        lines.append(f"    voice {_quote(voice)}")
    character = node.get("character") or default_char
    text = _wrap_text(node["text"], node.get("text_tags"), localize)
    lines.append(f"    {character} {text}")
    nxt = node.get("next")
    if nxt:
        lines.append(f"    jump dlg_{tree_id}__{nxt}")
    return lines


def _emit_choice(tree_id: str, node: Dict[str, Any], localize: bool) -> List[str]:
    lines: List[str] = []
    lines.append("    menu:")
    prompt = node.get("prompt")
    if prompt:
        lines.append(f"        {_wrap_text(prompt, localize=localize)}:")
        base = "            "
    else:
        base = "        "
    for ch in node.get("choices", []):
        line = base + _wrap_text(ch["text"], localize=localize)
        conds = ch.get("conditions") or []
        if conds:
            line += " if " + " and ".join(conds)
        line += ":"
        lines.append(line)
        for eff in ch.get("effects", []):
            lines.append(base + f"    $ {eff}")
        lines.append(base + f"    jump dlg_{tree_id}__{ch['next']}")
    return lines


def _emit_if(tree_id: str, node: Dict[str, Any]) -> List[str]:
    lines: List[str] = []
    branches = node.get("branches", [])
    for i, br in enumerate(branches):
        cond = br["condition"]
        target = br["next"]
        if cond == "True":
            lines.append("    else:")
        else:
            prefix = "if" if i == 0 else "elif"
            lines.append(f"    {prefix} {cond}:")
        lines.append(f"        jump dlg_{tree_id}__{target}")
    return lines


def _emit_script(tree_id: str, node: Dict[str, Any]) -> List[str]:
    lines: List[str] = []
    for code in node.get("code", []):
        lines.append(f"    $ {code}")
    nxt = node.get("next")
    if nxt:
        lines.append(f"    jump dlg_{tree_id}__{nxt}")
    return lines


def _emit_jump(node: Dict[str, Any]) -> List[str]:
    return [f"    jump {node['label']}"]


def _emit_call(node: Dict[str, Any]) -> List[str]:
    return [f"    call {node['label']}", "    return"]


def _emit_return() -> List[str]:
    return ["    return"]


def _emit_screen(tree_id: str, node: Dict[str, Any]) -> List[str]:
    lines: List[str] = []
    params = node.get("params", {})
    if params:
        args = ", ".join(f"{k}={repr(v)}" for k, v in params.items())
        lines.append(f"    call screen {node['screen']}({args})")
    else:
        lines.append(f"    call screen {node['screen']}")
    nxt = node.get("next")
    if nxt:
        lines.append(f"    jump dlg_{tree_id}__{nxt}")
    return lines


_EMITTERS = {
    "say": _emit_say,
    "choice": _emit_choice,
    "if": _emit_if,
    "script": _emit_script,
    "jump": lambda tree_id, n, dc=None, loc=True: _emit_jump(n),
    "call": lambda tree_id, n, dc=None, loc=True: _emit_call(n),
    "return": lambda tree_id, n, dc=None, loc=True: _emit_return(),
    "screen": _emit_screen,
}


def generate_rpy(data: Dict[str, Any]) -> Dict[Path | str, str]:
    """Generate Ren'Py dialogue files from validated ``data``.

    Returns a mapping of relative ``Path`` objects to file contents.
    String keys are included for backwards compatibility.
    """
    files: Dict[Path, str] = {}

    # Helpers file (currently minimal)
    files[Path("_gen/dialogs_helpers.rpy")] = "# AUTOGENERATED – DO NOT EDIT\n"

    project = data.get("project", {})
    default_char = project.get("default_character", "narrator")
    localize = "language" not in project

    for tree in data.get("dialog_trees", []):
        tid = tree["id"]
        lines: List[str] = []
        lines.append("# AUTOGENERATED – DO NOT EDIT")
        lines.append(f"label dlg_{tid}__start:")
        for loc in tree.get("locals", []):
            lines.append(f"    $ {loc['name']} = {repr(loc.get('default'))}")
        lines.append(f"    jump dlg_{tid}__{tree['entry_node']}")
        lines.append("")
        for node in tree.get("nodes", []):
            if node["type"] == "note":
                continue
            nid = node["id"]
            lines.append(f"label dlg_{tid}__{nid}:")
            emitter = _EMITTERS.get(node["type"])
            if emitter:
                if node["type"] == "say":
                    emitted = emitter(tid, node, default_char, localize)
                elif node["type"] == "choice":
                    emitted = emitter(tid, node, localize)
                else:
                    emitted = emitter(tid, node)
                lines.extend(emitted)
            else:
                lines.append(f"    # Unsupported node type: {node['type']}")
            lines.append("")
        content = "\n".join(lines).rstrip() + "\n"
        files[Path(f"_gen/dialogs_{tid}.rpy")] = content

    # Provide access via filename strings for compatibility
    result: Dict[Path | str, str] = {}
    for path, content in files.items():
        result[path] = content
        result[path.name] = content
    return result

# Backwards-compat: алиас, который ожидала другая ветка
generate = generate_rpy

__all__ = ["generate_rpy", "generate"]
